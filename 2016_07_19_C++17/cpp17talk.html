<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  width: 45em;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 30px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headeranchor-link {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

.markdown-body .headeranchor-link:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .headeranchor,
.markdown-body h2 .headeranchor,
.markdown-body h3 .headeranchor,
.markdown-body h4 .headeranchor,
.markdown-body h5 .headeranchor,
.markdown-body h6 .headeranchor {
  display: none;
  color: #000;
  vertical-align: middle;
}

.markdown-body h1:hover .headeranchor-link,
.markdown-body h2:hover .headeranchor-link,
.markdown-body h3:hover .headeranchor-link,
.markdown-body h4:hover .headeranchor-link,
.markdown-body h5:hover .headeranchor-link,
.markdown-body h6:hover .headeranchor-link {
  height: 1em;
  padding-left: 8px;
  margin-left: -30px;
  line-height: 1;
  text-decoration: none;
}

.markdown-body h1:hover .headeranchor-link .headeranchor,
.markdown-body h2:hover .headeranchor-link .headeranchor,
.markdown-body h3:hover .headeranchor-link .headeranchor,
.markdown-body h4:hover .headeranchor-link .headeranchor,
.markdown-body h5:hover .headeranchor-link .headeranchor,
.markdown-body h6:hover .headeranchor-link .headeranchor {
  display: inline-block;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px octicons-anchor;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\f05c';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><title>cpp17talk</title></head><body><article class="markdown-body"><h2 id="fabio-fracassi"><a name="user-content-fabio-fracassi" href="#fabio-fracassi" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Fabio Fracassi</h2>
<p><a href="http://fabio.fracassi.de">http://fabio.fracassi.de</a></p>
<h2 id="c17"><a name="user-content-c17" href="#c17" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>C++17</h2>
<p><strong>What it is not:</strong> Flashy signature featurs<br />
 * No Modules<br />
 * No Concepts<br />
 * No default comparisons</p>
<p>Those are great, but will have to wait a while longer.</p>
<hr />
<p><strong>What it is:</strong><br />
 * More library than language.<br />
 * A few big (though not flashy) features<br />
 * A lot of smaller Features that make stuff much easier<br />
 * Quite a few fixes</p>
<hr />
<p>if you want to know more follow the paper trail, <a href="http://wg21.link/[PN]xxxx">http://wg21.link/[PN]xxxx</a> <br />
will take you directly to the latest revision of the paper.</p>
<hr />
<h2 id="extending-our-vocabulary"><a name="user-content-extending-our-vocabulary" href="#extending-our-vocabulary" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Extending our vocabulary</h2>
<hr />
<h5 id="optional-from-lib-fundamentals"><a name="user-content-optional-from-lib-fundamentals" href="#optional-from-lib-fundamentals" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Optional (from Lib Fundamentals)</h5>
<pre><code>if (std::optional&lt;int&gt; value = get_thing()) {
    use(*value);
} else {
    log("meh!");
}
</code></pre>
<p>or more concisely (using exceptions for error handling):</p>
<pre><code>int value = get_thing().value()
</code></pre>
<p>or if you do not need errors but defaults:</p>
<pre><code>int value = get_thing().value_or(-1);
</code></pre>
<p>you should be using optional a lot. <br />
Basically every time you want to return a value that might not be there. <br />
Optional is purely stack based and has only a small overhead (1 byte + alignment)</p>
<hr />
<p><strong>The future:</strong> there is a very similar class in the works:</p>
<pre><code>expected&lt;Type, ErrorType&gt;
</code></pre>
<p>to be used when you want to also give a reason on why there is no value.</p>
<hr />
<h5 id="variant-woooooohooooooo"><a name="user-content-variant-woooooohooooooo" href="#variant-woooooohooooooo" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Variant (Woooooohooooooo!)</h5>
<p>a typesafe union, and an efficient way to do dynamic dispatch:</p>
<pre><code>//------------------- library: ----
using shape = std::variant&lt;std::monostate, point, line, rectangle&gt;;

auto intersect(shape const&amp; lhs, shape const&amp; rhs) -&gt; shape {
    return std::visit( 
                [](auto const&amp; lhs, auto const&amp; rhs ) { return intersect(lhs, rhs); }
                , lhs, rhs
           );
}

void show(shape const &amp; s) {
    std::visit( not_yet_std::overload(
                [](point const&amp; p)     { draw(p); }
                [](line const&amp; l)      { draw(l); }
                [](rectangle const&amp; r) { draw(r); }
              ), s);
}
//------------------- usage: ----
{
    Shape r1 = rectangle{ {5, 5}, {10, 10} };
    Shape r2 = rectangle{ {9, 5}, {15, 10} };
    Shape l1 = line{ {7, 4}, {8, 11} };

    auto i1 = intersect(r1, r2);
    auto i2 = intersect(r1, l1);
    auto i3 = intersect(r2, l1);

    show(i1);
    show(i2);
    show(i3);
}
</code></pre>
<p><strong>Good performance:</strong></p>
<ul>
<li>No Heap needed</li>
<li>amendable to compiler optimizations (const propagation, inlineing) </li>
<li>no aliasing</li>
</ul>
<p><strong>Easily understandable:</strong></p>
<ul>
<li>value semantics</li>
<li>bound(controlled) set of types</li>
</ul>
<hr />
<h5 id="any"><a name="user-content-any" href="#any" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Any</h5>
<p>the generic value type to use when anything else fails.<br />
or: &ldquo;a safer void pointer&rdquo;</p>
<p>A note of caution: Whenever you reach for this type, <br />
check if you can use variant instead, because more often than not <br />
variant is the better option</p>
<hr />
<h5 id="string_view"><a name="user-content-string_view" href="#string_view" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>string_view</h5>
<p>the simplest type you never knew you needed. </p>
<p>consider:</p>
<pre><code>void process(std::string const&amp; s);

auto hw = std::string("Hello World");
process("Hello World"); // meh! performance bug, temporary string on each call
process(hw);            // yay!
</code></pre>
<p>or: </p>
<pre><code>auto hw = std::string("Hello World");
process("Hello World"); // yay!
process(hw);            // does not even compile, need ugly hw.c_str();
</code></pre>
<p>solution pre- string_view: </p>
<pre><code>void process(std::string const&amp; s) { process(s.c_str()); }
void process(char const* sz);  // meh! no size, and can't use string stuff in here.
</code></pre>
<p>C++17:</p>
<pre><code>void process(std::string_view sv) // by value! safe interface

process("Hello World"); // yay, no temporaries
process(hw);            // works!
</code></pre>
<p>Whenever you do not need to take ownership of a string you should use <br />
<code>std::string_view</code> from now on. This will make your code conveniently and<br />
efficiently useable with any contigious char range.</p>
<p>A nice little example I thought of recently:</p>
<pre><code>template&lt;typename ... Strs&gt; auto string_cat(Strs ... strs) -&gt; std::string {  
   std::array&lt;std::string_view, sizeof...(Strs) av {std::string_view(strs)...};
   std::string r(accumulate(av, [](auto v){ return v.size(); }), '\0');
   size_t cpos = 0;
   for (auto const&amp; v : av) { 
      std::copy(v.begin(), v.end(), r.data() + cpos);  // std::string::data() can be non-const in 17
      cpos += v.size(); 
   }
}
</code></pre>
<p>One caveat:</p>
<p><code>string_view</code> is not guaranteed to be zero terminated! <br />
So be aware: </p>
<pre><code>void read_config(std::string_view sv) {
    // std::fstream(sv.data()); // BUGBUG!!!
    std::fstream(std::to_string(sv)); // Works, because it creates a temporary string
}
</code></pre>
<p><strong>solution:</strong> <em>???</em> I would suggest a zstring_view, that deals with the details</p>
<p><strong>future:</strong><br />
 we will get a very similar class <code>std::span&lt;T&gt;</code> soon after C++17<br />
<code>std::span&lt;char const&gt;</code> is nearly identical to string_view but with a lighter interface.<br />
<code>std::span&lt;char&gt;</code> can be used to change the underlying buffer. </p>
<hr />
<p>On that note: we have <strong>range based for with sentinels</strong> (<a href="http://wg21.link/P0184">P0184</a>) now, so: </p>
<pre><code>struct zstring_view {
    zstring_view(char const* p) : ptr_(p) {}
    zstring_view(std::string_view sv) : ptr_(sv.data()) { assert(*sv.back() == '\0'); }
    // more ctors ...

    struct iter {
        iter(char const* p) : ptr_(p) {}
        auto operator++() -&gt; iter&amp; { ++ptr_; return *this; }
        auto operator*() const -&gt; char { return *ptr_; }
        private: 
            char const* ptr_;
    };
    struct sentinel {};
    auto begin() -&gt; iter { return iter(ptr_); }
    auto end() -&gt; sentinel { return sentinel{}; }

    private: 
        char const* ptr_;
};
bool operator!=(zstring_view::iter const&amp; it, zstring_view::sentinel) { return *it != '\0'; }

zstring_view hello("Hello World");
for (auto c : hello) { do_something_with(c); } // look ma! no strlen!
</code></pre>
<hr />
<h2 id="language-features"><a name="user-content-language-features" href="#language-features" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Language features</h2>
<p>Ok, I lied, there are a few cool language features</p>
<p>and they integrate quite nicely, too.</p>
<hr />
<h5 id="selection-statements-with-initializer"><a href="http://wg21.link/P0305">Selection statements with initializer</a></h5>
<h5 id="structured-bindings"><a href="http://wg21.link/P0217">Structured bindings</a></h5>
<pre><code>std::map&lt;int, std::string&gt; m;
if (auto [pos, inserted] = m.insert({1701, "Live long and prosper!"}); !inserted) {
    std::cout &lt;&lt; "Of course you know Star Trek, welcome back!\n";
    use(pos);
} else {
    std::cout &lt;&lt; "Took you long enough! Welcome on board.\n";
}
</code></pre>
<p>Sweet sweet syntactic sugar!</p>
<p>it is not quite lambda expressions, but I expect seeing more multiple <br />
return value designs in the future.</p>
<hr />
<h5 id="template-argument-deduction-for-class-templates"><a href="http://wg21.link/P0091">Template argument deduction for class templates</a></h5>
<h5 id="nodiscard"><code>[[nodiscard]]</code></h5>
<h5 id="stduncaught_exceptions-n4259"><code>std::uncaught_exceptions</code> <a href="http://wg21.link/N4259">N4259</a></h5>
<p>getting rid of gratious factory functions</p>
<pre><code>template&lt;typename OnSuccessFn, typename OnFailureFn&gt; 
struct [[nodiscard]] sg_base {
    sg_base(OnSuccessFn osf, OnFailureFn off) 
        : exceptions_on_entry_{std::uncaught_exceptions()}
        , success_(osf)
        , failure_(off) 
    {}
    ~sg_base() {
        if(std::uncaught_exceptions() &gt; exceptions_on_entry_) { failure_(); }
                                                         else { success_(); }
    }
    private:
        int exceptions_on_entry_;
        OnSuccessFn success_;
        OnFailureFn failure_;
};
template&lt;typename Fn&gt; struct on_success : sg_base { on_success(Fn fn) : sg_base(fn, []{}) {}};
template&lt;typename Fn&gt; struct on_failure : sg_base { on_failure(Fn fn) : sg_base([]{}, fn) {}};
template&lt;typename Fn&gt; struct [[nodiscard]] on_exit { 
    on_exit(Fn fn) : exit_(fn) {} ~on_exit() { exit_(); } private: Fn exit_; 
};

{
    // on_exit (log("done!")); // that would be wrong, and the compiler will tell us!
    on_exit eg (log("done!"));  // look, no factory!
    Transaction t;
    on_success os([&amp;]{t.commit();});
    on_failure of([&amp;]{t.cleanup();});

    fill(t);    
}
</code></pre>
<p><strong>The future:</strong> </p>
<p>we will get some form of scope guards like those in a future standard. <a href="http://wg21.link/P0052">P0052</a></p>
<hr />
<h2 id="lots-more"><a name="user-content-lots-more" href="#lots-more" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Lots more &hellip;</h2>
<p>language and library</p>
<h5 id="searchers"><a name="user-content-searchers" href="#searchers" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>searchers</h5>
<pre><code>std::string haystack = load_text("TheCompleteWorksOfShakespeare.txt");
std::string needle = "Julia";

if  ( auto here = std::search( std::begin(haystack), std::end(haystack)
                             , std::make_boyer_moore_searcher( std::begin(needle)
                                                             , std::end(needle)))
    ; here != std::end(haystack)
    )
{
    romeo.julia_is(here);
} else {
    romeo.set_status(mood::sad);
}
</code></pre>
<hr />
<h5 id="elementary-string-conversions"><a href="http://wg21.link/p0067">Elementary string conversions</a></h5>
<p><code>to_chars</code> / <code>from_chars</code> writing out/parsing numbers, <br />
without locales, format strings, etc.</p>
<p>very low-level, efficient interface.</p>
<hr />
<h5 id="refining-expression-evaluation-order-for-idiomatic-c"><a href="http://wg21.link/P0145">Refining Expression Evaluation Order for Idiomatic C++</a></h5>
<p>make <code>future.then().then()</code> work!<br />
or <code>str.replace().replace().replace()</code></p>
<p>guaranteed order for<br />
    assignment: <code>x = y</code>   <code>x += y</code>    <code>x -= y</code>    &hellip;  (y before x)<br />
everything else, left to right:</p>
<pre><code>x &lt;&lt; y 
x &gt;&gt; y
x.y
x-&gt;y
...
</code></pre>
<p>still indetermined order:<br />
<code>f(a,b,c)</code> but no interleaving any longer between a,b,c</p>
<hr />
<h5 id="void_t"><a href="http://wg21.link/N3911">void_t</a></h5>
<pre><code>namespace std { template &lt;class...&gt; using void_t = void; }
</code></pre>
<p>that&rsquo;s it! The whole feature! </p>
<p>It is simple but fairly useful:</p>
<pre><code>template&lt; class, class = void &gt; 
struct has_render_member                               : std::false_type {};
template&lt; class T &gt; 
struct has_render_member &lt;T, std::void_t&lt;T::render()&gt;&gt; : std::true_type  {};
</code></pre>
<hr />
<h5 id="if-constexpr"><a href="http://wg21.link/P0292">if constexpr</a></h5>
<pre><code>template&lt;typename App&gt; struct app {
    void run() {
        if constexpr (has_render_with_time_member_v&lt;App&gt;) {
            auto start = clock::now();
            while (!close_requested()) {
                auto now = clock::now();
                render(now - start);
            }
        } else if constexpr (has_render_member_v&lt;App&gt;) {
            while (!close_requested()) { render(); }
        } else {
            static_assert( std::is_same_v&lt;App, App&gt;
                         , "you need to implement render() or render(duration)"
                         );
        }
    }
};
</code></pre>
<hr />
<h5 id="constexpr-lambda"><a href="http://wg21.link/P0170">Constexpr Lambda</a></h5>
<pre><code>auto addOne = [](int n) { return n + 1; };
static_assert( addOne(3) == 4);
</code></pre>
<p>oh, the last one is: <strong><a href="http://wg21.link/N3928">improved static_assert</a></strong> btw:</p>
<pre><code>static_assert(sizeof(T) &gt; 4); // compiler should now give a good message like:
                              //    sizeof(T) &gt; 4 [with T = myInt] failed.
</code></pre>
<hr />
<h5 id="lambda-capture-of-this-by-value-p0018"><a name="user-content-lambda-capture-of-this-by-value-p0018" href="#lambda-capture-of-this-by-value-p0018" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Lambda Capture of <code>*this</code> by value <a href="http://wg21.link/P0018">P0018</a></h5>
<p>you couldn&rsquo;t do <code>[=,*this]</code> before, which lead to strange<br />
javascripty workarounds like <code>[=, self = *this] { ... self-&gt;meh(); }</code></p>
<hr />
<h5 id="ordered-by-default"><a href="http://wg21.link/p0181">Ordered by Default</a></h5>
<pre><code>my_complex x{10.3, -2.3}, y{1.3, 2.7};
bool smaller = x &lt; y; // doesn't make sense, should not compile
template &lt;&gt; struct default_order&lt;my_complex&gt; { using type = my_complex_map_order; };
std::map&lt;my_complex, some_data&gt; cmap = /* ... */;
</code></pre>
<hr />
<h5 id="extending-memory-management-tools"><a href="http://wg21.link/p0040">Extending memory management tools</a></h5>
<p><code>uninitialized_*</code></p>
<hr />
<h5 id="make_from_tuple"><a href="http://wg21.link/p0209">make_from_tuple</a></h5>
<pre><code>struct X { X(int, float); X(int, int, float)};
tuple&lt;int, int, float&gt; t{1, 2, 3.0};
auto x = std::make_form_tuple&lt;X&gt;(t); // constructs X using the second ctor
</code></pre>
<hr />
<h5 id="splicing-maps-and-sets"><a href="http://wg21.link/p0083">Splicing Maps and Sets</a></h5>
<hr />
<h5 id="contiguous-iterators"><a href="http://wg21.link/N4284">Contiguous Iterators</a></h5>
<p>new iterator category which allows to exploit more optimizations<br />
   (e.g. SIMD operations)</p>
<hr />
<h5 id="variadic-lock_guard"><a href="http://wg21.link/P0156">Variadic lock_guard</a></h5>
<pre><code>{
    auto lk = lock_guard(mx1, mx2, mx3);

}
</code></pre>
<hr />
<h5 id="clamp-a-value-between-a-pair-of-boundary-values-p0025"><code>clamp</code> a value between a pair of boundary values <a href="http://wg21.link/P0025">P0025</a></h5>
<pre><code>auto red = std::clamp(input.red, 0, 255);
</code></pre>
<hr />
<h5 id="not_fn-p0005"><code>not_fn</code> <a href="http://wg21.link/P0005">P0005</a></h5>
<pre><code>std::remove_if(v.begin(), v.end(), std::not_fn(my_type::is_valid));
</code></pre>
<hr />
<h5 id="declaring-non-type-template-parameters-with-auto-p0127"><a name="user-content-declaring-non-type-template-parameters-with-auto-p0127" href="#declaring-non-type-template-parameters-with-auto-p0127" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Declaring non-type template parameters with auto <a href="http://wg21.link/P0127">P0127</a></h5>
<pre><code>template &lt; auto T t &gt; struct constant { constexpr T value = t };
</code></pre>
<hr />
<h5 id="shared_mutex"><a href="http://wg21.link/N4508">shared_mutex</a></h5>
<p>This one was missing, you need it to implent efficient single producer/multiple consumer scenarios</p>
<hr />
<h2 id="invisible-goodies"><a name="user-content-invisible-goodies" href="#invisible-goodies" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Invisible? goodies</h2>
<p>those will help you even if you do not know they are there, <br />
or you have been using them for a while even though they were not stantdard</p>
<hr />
<h5 id="guaranteed-copy-elision"><a href="http://wg21.link/P0135">guaranteed copy elision</a></h5>
<p>Every major compiler has been doing this for several years anyway. <br />
the guarantee allows non-copyable, non-moveable types to be <br />
returned from (e.g. factory) functions</p>
<hr />
<h5 id="non-const-data-for-stdstring-p0272"><a name="user-content-non-const-data-for-stdstring-p0272" href="#non-const-data-for-stdstring-p0272" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>non-const <code>.data()</code> for <code>std::string</code> <a href="http://wg21.link/P0272">P0272</a></h5>
<hr />
<h5 id="allow-for-inline-variables"><a href="http://wg21.link/P0386">allow for inline variables</a></h5>
<pre><code>namespace mine {
    inline int global = 10; // look ma, I already got my value!
}
// no need to define int mine::global = 10 in a separete and unique TU.
</code></pre>
<p>But global state is evil! <br />
 Why is this great? </p>
<p>One Word: <strong>Header only libraries!</strong> </p>
<hr />
<h2 id="small-goodies"><a name="user-content-small-goodies" href="#small-goodies" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Small goodies</h2>
<pre><code>switch(i) {
    case 1: unique_action(); break;
    case 2: prepare(); [[fallthrough]] // trust me I think I know what I am doing!
    case 3: action(); break
    // ... 
}
</code></pre>
<hr />
<pre><code>template&lt;template&lt;typename...&gt; typename Container&gt; auto accumulate(Container const&amp; c);
//                             ^^^^ you had to write class here before (meh!)
</code></pre>
<hr />
<p><strong>u8 character literals</strong> <a href="http://wg21.link/N4267">N4267</a> <code>auto utf8 = "Hällo Wórld: "u8;</code></p>
<hr />
<h5 id="constant-view-stdas_const-p0007"><a name="user-content-constant-view-stdas_const-p0007" href="#constant-view-stdas_const-p0007" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Constant View: <code>std::as_const</code> <a href="http://wg21.link/P0007">P0007</a></h5>
<pre><code>void my_func(std::vector&lt;int&gt;&amp; v) {
    modify(v);
    do_something(std::as_const(v)); // make sure that the non modifing do_something gets called
}
</code></pre>
<hr />
<h5 id="improved-insertion-interface-for-unique-key-maps-n4279"><a name="user-content-improved-insertion-interface-for-unique-key-maps-n4279" href="#improved-insertion-interface-for-unique-key-maps-n4279" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Improved insertion interface for unique-key maps <a href="http://wg21.link/N4279">N4279</a></h5>
<pre><code>std::map&lt;int, Heavy&gt; m;
// insert stuff
m.try_emplace(42, ??? )
</code></pre>
<hr />
<h5 id="emplace-return-type"><a href="http://wg21.link/p0084">Emplace Return Type</a></h5>
<p><code>m.emplace(Heavy(45, 34)).set_heavy_param(5);</code><br />
  Note: doesn&rsquo;t work for push_back (abi issues)</p>
<hr />
<h5 id="non-member-size"><a name="user-content-non-member-size" href="#non-member-size" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Non-member <code>size()</code></h5>
<p>free functions work better in generic code</p>
<hr />
<h5 id="improved-pair-and-tuple"><a href="http://wg21.link/N4387">Improved pair and tuple</a></h5>
<pre><code>// std::tuple&lt;int, int&gt; foo_tuple() { return {1, -1};  /* tuple ctor is always explicit in C++14 */ }
std::tuple&lt;int, int&gt; foo_tuple()    { return std::tuple&lt;int, int&gt;{1, -1};  /* OK in C++14 */ }
std::tuple&lt;int, int&gt; foo_tuple()    { return {1, -1};     /* Now works in C++17 */ }
</code></pre>
<hr />
<h5 id="minimal-incomplete-type-support-for-standard-containers-n4510"><a name="user-content-minimal-incomplete-type-support-for-standard-containers-n4510" href="#minimal-incomplete-type-support-for-standard-containers-n4510" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Minimal incomplete type support for standard containers <a href="http://wg21.link/N4510">N4510</a></h5>
<pre><code>struct entry { std::vector&lt;entry&gt; sub_entries_; };
</code></pre>
<hr />
<h5 id="bool_constant"><a href="http://wg21.link/N4389">bool_constant</a></h5>
<pre><code>template &lt;bool B&gt; using bool_constant = integral_constant&lt;bool, B&gt;;

using true_type  = integral_constant&lt;bool, true&gt;;
using false_type = integral_constant&lt;bool, false&gt;;
</code></pre>
<hr />
<h5 id="dynamic-memory-allocation-for-over-aligned-data-p0035"><a name="user-content-dynamic-memory-allocation-for-over-aligned-data-p0035" href="#dynamic-memory-allocation-for-over-aligned-data-p0035" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Dynamic memory allocation for over-aligned data <a href="http://wg21.link/P0035">P0035</a></h5>
<pre><code>auto ap = std::unique_ptr&lt;int[]&gt;(new(sizeof(int) * count, std::align_val_t(alignof(simd::vec128_t))));
</code></pre>
<hr />
<h2 id="removed-stuff"><a name="user-content-removed-stuff" href="#removed-stuff" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Removed stuff</h2>
<p>we are finally getting ready to remove cruft.</p>
<p><strong>Removing trigraphs??!</strong> <a href="http://wg21.link/N4086">N4086</a> no need to wonder why <code>std::cout &lt;&lt; "WTF ??!\n";</code> behaves so strange. </p>
<p><strong>Removing <code>auto_ptr</code>, <code>random_shuffle()</code>, And Old <code>&lt;functional&gt;</code> Stuff <a href="http://wg21.link/N4190">N4190</a></strong><br />
    if you are still using those: <em>go! fix! your! @#$@Q#$^R! code!</em></p>
<hr />
<h2 id="even-more-new-stuff"><a name="user-content-even-more-new-stuff" href="#even-more-new-stuff" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Even more new stuff &hellip;</h2>
<h5 id="parallel-algorithms"><a href="http://wg21.link/P0024">Parallel Algorithms</a></h5>
<p>Parallel versions of STL algorithms, plus a few extras</p>
<pre><code>std::transform_reduce( std::execution::unseq
                     , std::begin(data), std::end(data)
                     , [](auto const&amp; de){ return process_element(de); }
                     , result
                     , [](auto const&amp; rhs, auto const&amp; lhs) {
                            return merge(rhs, lhs);
                       }
                     );
</code></pre>
<hr />
<h5 id="file-system"><a href="http://wg21.link/P0218">File System</a></h5>
<pre><code>for ( auto const&amp; entry : std::filesystem::recursive_directory_iterator(
                                std::filesystem::path("/opt")
                          )
    ) 
{
    process(it-&gt;path());
}
</code></pre>
<hr />
<h5 id="folding-expressions"><a href="http://wg21.link/N4295">Folding expressions</a></h5>
<pre><code>template&lt;typename... Args&gt; bool all(Args... args) { 
    return (args &amp;&amp; ...); 
}

bool b = all(true, true, true, false);
</code></pre>
<hr />
<h2 id="and-on-and-on-and-on"><a name="user-content-and-on-and-on-and-on" href="#and-on-and-on-and-on" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>And on and on and on</h2>
<h5 id="c17-rebased-on-c11-instead-of-c99-p0063"><a name="user-content-c17-rebased-on-c11-instead-of-c99-p0063" href="#c17-rebased-on-c11-instead-of-c99-p0063" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>C++17 rebased on C11 instead of C99 <a href="http://wg21.link/p0063">P0063</a></h5>
<h5 id="polymorphic-allocators"><a name="user-content-polymorphic-allocators" href="#polymorphic-allocators" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>polymorphic allocators</h5>
<h5 id="allow-constant-evaluation-for-all-non-type-template-arguments-n4268"><a name="user-content-allow-constant-evaluation-for-all-non-type-template-arguments-n4268" href="#allow-constant-evaluation-for-all-non-type-template-arguments-n4268" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Allow constant evaluation for all non-type template arguments <a href="http://wg21.link/N4268">N4268</a></h5>
<h5 id="n4089-safe-conversions-in-unique_ptr"><a href="http://wg21.link/N4089">N4089</a> Safe conversions in unique_ptr<T[]></h5>
<h5 id="p0074-making-stdowner_less-more-flexible"><a href="http://wg21.link/P0074">P0074</a> Making std::owner_less more flexible</h5>
<h5 id="p0092-polishing"><a href="http://wg21.link/P0092">P0092</a> Polishing <chrono></h5>
<h5 id="n4258-cleaning-up-noexcept-in-the-library"><a href="http://wg21.link/N4258">N4258</a> Cleaning-up noexcept in the Library</h5>
<h5 id="p0004-remove-deprecated-iostreams-aliases"><a href="http://wg21.link/P0004">P0004</a> Remove Deprecated iostreams aliases</h5>
<h5 id="p0137-replacement-of-class-objects-containing-reference-members"><a href="http://wg21.link/P0137">P0137</a> Replacement of class objects containing reference members</h5>
<h5 id="p0283-standard-and-non-standard-attributes"><a href="http://wg21.link/P0283">P0283</a> Standard and non-standard attributes</h5>
<h5 id="p0295-adopt-selected-library-fundamentals-v2-components-for-c17"><a href="http://wg21.link/p0295">P0295</a> Adopt Selected Library Fundamentals V2 Components for C++17</h5>
<h5 id="p0017-extension-to-aggregate-initialization"><a href="http://wg21.link/P0017">P0017</a> Extension to aggregate initialization</h5>
<h5 id="p0036-unary-folds-and-empty-parameter-packs-revision-1"><a href="http://wg21.link/P0036">P0036</a> Unary Folds and Empty Parameter Packs (revision 1)</h5>
<h5 id="p0138-construction-rules-for-enum-class-values"><a href="http://wg21.link/P0138">P0138</a> Construction Rules for enum class Values</h5>
<h5 id="p0245-hexadecimal-floating-literals-for-c"><a href="http://wg21.link/P0245">P0245</a> Hexadecimal floating literals for C++</h5>
<h5 id="p0226-mathematical-special-functions-for-c17"><a href="http://wg21.link/P0226">P0226</a> Mathematical Special Functions for C++17</h5>
<h5 id="p0033-re-enabling-shared_from_this-revision-1"><a href="http://wg21.link/P0033">P0033</a> Re-enabling shared_from_this (revision 1).</h5>
<h5 id="p0152-constexpr-atomicis_always_lock_free"><a href="http://wg21.link/P0152">P0152</a> constexpr atomic::is_always_lock_free.</h5>
<h5 id="p0185-adding-nothrow-swappable-traits-revision-3"><a href="http://wg21.link/P0185">P0185</a> Adding [nothrow-]swappable traits, revision 3.</h5>
<h5 id="p0253-fixing-a-design-mistake-in-the-searchers-interface"><a href="http://wg21.link/P0253">P0253</a> Fixing a design mistake in the searchers interface.</h5>
<h5 id="p0154-constexpr-stdhardware_constructivedestructive_interference_size"><a href="http://wg21.link/P0154">P0154</a> constexpr std::hardware_{constructive,destructive}_interference_size.</h5>
<h5 id="p0030-proposal-to-introduce-a-3-argument-overload-to-stdhypot"><a href="http://wg21.link/P0030">P0030</a> Proposal to Introduce a 3-Argument Overload to std::hypot.</h5>
<h5 id="p0031-a-proposal-to-add-constexpr-modifiers-to-reverse_iterator-move_iterator-array-and-range-access-and-apply-the-resolution-of-lwg-issue-2296-stdaddressof-should-be-constexpr"><a href="http://wg21.link/P0031">P0031</a> A Proposal to Add Constexpr Modifiers to reverse_iterator, move_iterator, array and Range Access and apply the resolution of LWG Issue 2296 - std::addressof should be constexpr</h5>
<h5 id="p0077-is_callable-the-missing-invoke-related-trait"><a href="http://wg21.link/P0077">P0077</a> is_callable, the missing INVOKE related trait.</h5>
<h5 id="p0175-synopses-for-the-c-library"><a href="http://wg21.link/p0175">p0175</a> Synopses for the C library</h5>
<h5 id="p0307-making-optional-greater-equal-again"><a href="http://wg21.link/p0307">p0307</a> Making Optional Greater Equal Again</h5>
<h5 id="p0393-making-variant-greater-equal"><a href="http://wg21.link/p0393">p0393</a> Making Variant Greater Equal</h5>
<h5 id="p0032-homogeneous-interface-for-variant-any-and-optional"><a href="http://wg21.link/p0032">p0032</a> Homogeneous interface for variant, any and optional</h5>
<h5 id="p0254-integrating-stdstring_view-and-stdstring"><a href="http://wg21.link/p0254">p0254</a> Integrating std::string_view and std::string</h5>
<h5 id="p0258-has_unique_object_representations"><a href="http://wg21.link/p0258">p0258</a> has_unique_object_representations</h5>
<h5 id="p0302-removing-allocator-support-in-stdfunction"><a href="http://wg21.link/p0302">p0302</a> Removing Allocator Support in std::function</h5>
<h5 id="p0163-shared_ptrweak_type"><a href="http://wg21.link/p0163">p0163</a> shared_ptr::weak_type</h5>
<h5 id="p0174-deprecating-vestigial-library-parts-in-c17"><a href="http://wg21.link/p0174">p0174</a> Deprecating Vestigial Library Parts in C++17</h5>
<h5 id="p0337-delete-operator-for-polymorphic_allocator"><a href="http://wg21.link/p0337">p0337</a> Delete operator= for polymorphic_allocator</h5>
<h5 id="p0358-fixes-for-not_fn"><a href="http://wg21.link/p0358">p0358</a> Fixes for not_fn</h5>
<h5 id="p0219-relative-paths-for-filesystem"><a href="http://wg21.link/p0219">p0219</a> Relative Paths for Filesystem</h5>
<h5 id="p0392-adapting-string_view-by-filesystem-paths"><a href="http://wg21.link/p0392">p0392</a> Adapting string_view by filesystem paths</h5>
<h5 id="p0394-hotel-parallelifornia-terminate-for-parallel-algorithms-exception-handling"><a href="http://wg21.link/P0394">P0394</a> Hotel Parallelifornia: terminate() for Parallel Algorithms Exception Handling</h5>
<h5 id="p0336-better-names-for-parallel-execution-policies-in-c17"><a href="http://wg21.link/p0336">p0336</a> Better Names for Parallel Execution Policies in C++17</h5>
<h5 id="p0371-temporarily-discourage-memory_order_consume"><a href="http://wg21.link/p0371">p0371</a> Temporarily discourage memory_order_consume</h5>
<h5 id="p0346-a-nomenclature-tweak"><a href="http://wg21.link/p0346">p0346</a> A <random> Nomenclature Tweak</h5>
<h5 id="p0180-reserve-a-new-library-namespace-for-future-standardization"><a href="http://wg21.link/p0180">p0180</a> Reserve a New Library Namespace for Future Standardization</h5>
<h5 id="p0296-forward-progress-guarantees-base-definitions"><a href="http://wg21.link/P0296">P0296</a> Forward progress guarantees: Base definitions</h5>
<h5 id="p0299-forward-progress-guarantees-for-the-parallelism-ts-features"><a href="http://wg21.link/P0299">P0299</a> Forward progress guarantees for the Parallelism TS features</h5>
<h5 id="n4261-proposed-resolution-for-core-issue-330-qualification-conversions-and-pointers-to-arrays-of-pointers"><a href="http://wg21.link/N4261">N4261</a> Proposed resolution for Core Issue 330: Qualification conversions and pointers to arrays of pointers</h5>
<h5 id="p0012-make-exception-specifications-be-part-of-the-type-system"><a href="http://wg21.link/P0012">P0012</a> Make exception specifications be part of the type system</h5>
<h5 id="p0002-remove-deprecated-operatorbool"><a href="http://wg21.link/P0002">P0002</a> Remove Deprecated operator++(bool)</h5>
<h5 id="n3922-new-rules-for-auto-deduction-from-braced-init-list"><a href="http://wg21.link/N3922">N3922</a> New Rules for auto deduction from braced-init-list</h5>
<h5 id="p0001-remove-deprecated-use-of-the-register-keyword"><a href="http://wg21.link/P0001">P0001</a> Remove Deprecated Use of the register Keyword</h5>
<h5 id="n4266-attributes-for-namespaces-and-enumerators"><a href="http://wg21.link/N4266">N4266</a> Attributes for namespaces and enumerators</h5>
<h5 id="n4230-nested-namespace-definition"><a href="http://wg21.link/N4230">N4230</a> Nested namespace definition</h5>
<h5 id="p0136-rewording-inheriting-constructors-core-issue-1941-et-al"><a href="http://wg21.link/P0136">P0136</a> Rewording inheriting constructors (core issue 1941 et al)</h5>
<h5 id="p0134-introducing-a-name-for-brace-or-equal-initializers-for-non-static-data-members"><a href="http://wg21.link/P0134">P0134</a> Introducing a name for brace-or-equal-initializers for non-static data members</h5>
<h5 id="n4262-wording-for-forwarding-references"><a href="http://wg21.link/N4262">N4262</a> Wording for Forwarding References</h5>
<h5 id="n4285-cleanup-for-exception-specification-and-throw-expression"><a href="http://wg21.link/N4285">N4285</a> Cleanup for exception-specification and throw-expression</h5>
<h5 id="p0061-__has_include-for-c17"><a href="http://wg21.link/P0061">P0061</a> __has_include for C++17</h5>
<h5 id="n4366-lwg-2228-missing-sfinae-rule-in-unique_ptr-templated-assignment"><a href="http://wg21.link/N4366">N4366</a> LWG 2228: Missing SFINAE rule in unique_ptr templated assignment</h5>
<h5 id="n4169-a-proposal-to-add-invoke-function-template"><a href="http://wg21.link/N4169">N4169</a> A proposal to add invoke function template</h5>
<h5 id="n4277-triviallycopyable-reference_wrapper"><a href="http://wg21.link/N4277">N4277</a> TriviallyCopyable reference_wrapper</h5>
<h5 id="p0006-adopt-type-traits-variable-templates-from-library-fundamentals-ts-for-c17"><a href="http://wg21.link/P0006">P0006</a> Adopt Type Traits Variable Templates from Library Fundamentals TS for C++17</h5>
<h5 id="p0013-logical-operator-type-traits"><a href="http://wg21.link/P0013">P0013</a> Logical Operator Type Traits</h5>
<h5 id="p0391-p0391r0-introducing-the-term-templated-entity"><a href="http://wg21.link/P0391">P0391</a> P0391R0: Introducing the term &lsquo;templated entity&rsquo;</h5>
<h5 id="p0398-p0398r0-core-issue-1518-explicit-default-constructors-and-copy-list-initialization"><a href="http://wg21.link/P0398">P0398</a> P0398R0: Core issue 1518: Explicit default constructors and copy-list-initialization</h5></article></body></html>